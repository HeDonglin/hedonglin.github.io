---
title: 如何提高网站性能总结
date: 2017-06-27 01:10:33
categories: 网站
tags: 性能
---
## 了解浏览器解析与执行过程
html从上往下执行>>>遇到head中link向服务器请求css文件>>>解析css树（选择符是从右到左进行匹配）>>>遇到body标签里的部分代码结合css进行布局>>>遇到img标签向服务器请求并继续渲染后面的代码>>>图片下载后图片的大小影响了布局浏览器回头重新渲染该部分代码>>>遇到脚本解析并执行（但是会阻塞页面后续的内容（包括页面的渲染、其它资源的下载））>>>如果执行过程中发现代码需要隐藏某部分内容浏览器会重新渲染该部分代码>>>当用户点击换肤按钮>>>浏览器向服务器发出请求重新渲染页面

## 了解互联网协议
[互联网协议入门（一）阮一峰](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html?20151020222130)
[互联网协议入门（二）阮一峰](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)

## 了解DNS原理
[DNS 原理入门阮一峰](http://www.ruanyifeng.com/blog/2016/06/dns.html)

## 了解HTTP协议
《HTTP权威指南》
[HTTP 协议入门阮一峰](http://www.ruanyifeng.com/blog/2016/08/http.html)

## 了解TCP/IP协议
《TCP/IP网络与协议》---兰少华, ‎杨余旺, ‎吕建勇 
《TCP/IP协议原理与应用(第4版)》
《TCP/IP详解卷1：协议》
《TCP/IP详解卷2：实现》
《TCP/IP详解卷3：TCP事务协议、HTTP、NNTP和UNIX域协议》

## 关于网站性能分析（最好先了解相关协议）
《Web性能权威指南》--强烈推荐
《高性能网站建设指南》
《高性能网站进阶指南》
《构建高性能Web站点》

## 页面内容
### 减少HTTP请求次数---节省服务器带宽，提高性能
html,css,js压缩合并；（注意：带来一个问题如果该页面有些内容是不需要的，如何清除）
降低图片大小；零星细小的图片采用雪碧图
避免重定向

### 减少DNS查询次数---减少域名主机，合理分配主机个数
为达到更高的性能，DNS解析通常被多级别地缓存。如由ISP或本地网络维护的DNS缓存服务器，用户机器操作系统的缓存。
减少域名主机可减少DNS查询的次数，但可能造成并行下载数的减少。避免 DNS查询可减少响应时间，而减少并行下载数可能增加响应时间。一个可行的折中是把内容分布到至少2个，最多4个不同的主机名上。

### 缓存Ajax

### 延迟加载
用户还没预览的地方不加载，等到用户滚动滚动条后才开始加载
延迟加载需要我们知道我们的网页最初加载需要的最小内容集是什么。剩下的内容就可以推到延迟加载的集合中。

### 提前加载
提前加载一些加接下来网页中访问的资源
无条件提前加载：当前网页加载完成后，马上去下载一些其他的内容。
有条件加载：根据用户的输入推断需要加载的内容

### 减少DOM元素数量
document.getElementsByTagName('*').length查看网页有多少DOM,在1000以下比较合适；但是在各大网站中都达到4-5千个dom，他们一般通过延迟加载，当用户滚动滚动条时候在最底部就开始加载剩下的；

### 根据域名划分内容
一般网站规划会将静态资源放在类似于static.example.com，动态内容放在www.example.com上。这样做还有一个好处是可以在静态的域名上避免使用cookie。后面我们会在cookie的规则中提到。 

### 减少iframe数量
优点：
可以用来加载速度较慢的内容，例如广告。
安全沙箱保护。浏览器会对iframe中的内容进行安全控制。
脚本可以并行下载
缺点：
即使iframe内容为空也消耗加载时间
会阻止页面加载
没有语义

### 避免404
我们网页中需要加载一个外部脚本，结果返回一个404，不仅阻塞了其他脚本下载，下载回来的内容(404)客户端还会将其当成Javascript去解析
网站根目录下放置favicon.ico

## 服务器

### 强制本地缓存---精确的缓存控制
Pragma(本地缓存，http1.0)
Expires(本地缓存,http1.0,缓存时间相对服务器上的时间)
Cache-Control(本地缓存,http1.1，缓存时间相对客户端时间)
Etag(协商缓存,http1.1,值是根据索引节，大小和最后修改时间进行Hash处理得到的值)
Last-Modified(协商缓存，http1.1，值是根据资源最后修改时间得到)
If-None-Match（资源过期则带上Etag值跟服务器Etag对比，相同返回304缓存中读取，不相同返回200更新内容）
If-Modified-Since（资源过期则带上Last-Modified值跟服务器Last-Modified值对比，相同返回304缓存中读取，不相同返回200更新内容）
本地缓存：Pragma-->Cache-control-->Expires
协商缓存：Etag-->last-Modified
使用缓存带来的几个问题：
    集群环境下，应该舍弃Last-Modified而用etag，各个服务器上的文件时间可能不同，或者同一服务器不同路径的相同文件也时间不同；
    Etag在多服务器的时候，索引节不一样，导致用户有可能重复下载，解决办法可采用大小和最后修改时间进行Hash就完美了；
```
F5：根据last-Modified的值
    IE请求头：
        If-Modified-Since
    火狐请求头： 
        Cache-Control："max-age=0"
        If-Modified-Since
    谷歌请求头：
        Cache-Control: "max-age=0"
        If-Modified-Since

ctrl+F5
    火狐、谷歌请求头：
        Pragma:"no-cache"
        Cache-Control:"no-cache"

    IE请求头:
        Cache-Control:"no-cache"
```


### 减少cookie大小或页面内容使用无cookie域名
比如图片CSS等静态文件放在静态资源服务器上并配置单独域名，客户端请求静态文件的时候，减少COOKIE反复传输时对主域名的影响。

### 采用CDN内容分发网络---缩短距离，优化网络请求

### 压缩要传输的文件(Gzip)---减少传输时间

### 避免空的图片src---减少多余的请求
空的图片src仍然会使浏览器发送请求到服务器，这样完全是浪费时间，而且浪费服务器的资源。

## Css
### 样式表放在头部---避免白屏

### 避免回流与重绘
预先定义好类名,只需修改DOM上的类名属性值
为动画的html元件使用absolute或fixed
不使用table布局
不要把DOM 结点的属性值放在一个循环里当成循环里的变量

### 避免CSS表达式---减少性能损耗

### 设置通用样式---多页面共享缓存，加快渲染，节省内容大小

### 避免使用filters
滤镜的使用会导致图片在下载的时候阻塞网页绘制，另外使用这种滤镜会导致内存使用量的问题。IE9中已经不再支持。

## Javascript

### 脚本放在底部
脚本执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）
将所有的script标签放到页面底部，也就是body闭合标签之前

### 去除重复脚本---减少文件大小
使用webpack构建工具

### 减少DOM访问---加快网页性能

### 使用智能事件处理
利用时间冒泡，把事件加到父级上触发每个子元素相同的事件

## 图片
### 优化图片质量，降低图片大小

### 合并零星图片，采用雪碧图

### 不要在html中缩放图片

### 使用小且可缓存的favico.ico

### 使用svg代替

### 使用bash64
这类图片不能与其他图片以CSS Sprite的形式存在，只能独行
这类图片从诞生之日起，基本上很少被更新
这类图片的实际尺寸很小
这类图片在网站中大规模使用

## 其他

### 尽最大可能重用已经建立的 TCP 连接(长连接)

### 采用非覆盖方式发布--平滑升级
