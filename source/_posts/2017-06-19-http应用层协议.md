---
title: Http应用层协议
date: 2017-06-19 11:11:48
categories: 服务器
tags: 协议
---
## http协议作用
不涉及数据包传输，主要规定客户端与服务端之间的通讯格式，默认采用80端口
## http技术方向图
<img src="/images/http-2.png" alt="http-2.png">
*****

## http发展历程
### http/0.9 ***1991年*** `GET`
### http/1.0 ***1996年5月*** `GET` `POST` `HEAD`
* 特点：改变了请求格式，新增了头信息，每次通信都包含头信息，头信息必须是 ASCII 码，后面的数据可以是任何格式；
* 缺点：短连接，每个TCP连接只能发送一个请求，等待服务器做出响应，其他请求必须重新新建连接
* 解决：connection:keep-alive(非标准)要求服务器不要关闭TCP连接，复用连接；

### http/1.1 ***1997年1月*** `GET` `POST` `HEAD` `OPTIONS` `DELETE` `PUT` `CONNECT` `TRACE` 
* 特点：头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制，持续连接(也称长连接，默认不关闭，没活动自动关闭)，管道机制(也称HTTP复用同一个TCP里可以同时发送多个请求)，分块传输编码(Transfer-Encoding:chunked，回应数量未定的数据块组成，采用流模式取代缓存模式，可以不使用Content-Length字段，因为Content-Length字段必须知道回应的数据长度)
* 缺点：队头堵塞，同一个TCP发送多个请求，回应时按照请求顺序回应，一旦前面的特别慢，后面的请求就在等待中；
* 解决：减少请求数，同时多开持续连接；

### SPDY协议 ***2009年*** 
谷歌自行研发的协议主要解决HTTP/1.1 效率不高的问题，HTTP/2 的基础
### http/2   ***2015年***
* 二进制协议：头信息和数据体都是二进制，并且统称为"帧"
* 多工：在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，双向的、实时的通信
* 数据流：数据包做标记，指出它属于哪个回应，HTTP/2 将每个请求或回应的所有数据包，称为一个数据流，每个数据流都有一个独一无二的编号，数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流，客户端还可以指定数据流的优先级
* 头信息压缩：一方面头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。
* 服务器推送：允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送，例如服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了
*****

## 浏览器多开持续连接数
<img src="/images/http-17.png" alt="http-17.png">
## http报文格式
<img src="/images/http-15.png" alt="http-15.png">
## 请求格式
　　请求行:（请求方法 URL HTTP协议版本）
　　请求头部：（属性：值）
　　空行（回车换行）
　　请求数据：（数据）
```js
"请求方法"
GET     请求指定的页面信息，并返回实体主体。
POST    向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST请求可能会导致新的资源的建立和/或已有资源的修改。
HEAD    类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头
OPTIONS 允许客户端查看服务器的性能。
DELETE  请求服务器删除指定的页面。
PUT     从客户端向服务器传送的数据取代指定的文档的内容。
CONNECT HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。
TRACE   回显服务器收到的请求，主要用于测试或诊断。
```

## 响应格式
　　状态行：(http协议版本号 状态码 状态消息)
　　消息报头
　　空行
　　响应正文
```js
"状态码"
1xx 表示通知信息，请求收到了或正在进行处理
2xx 表示成功，动作被成功接收、理解和接受
3xx 表示重定向，要完成请求必须采取下一步的行动
4xx 表示客户的错误，请求包含语法错误或无法完成请求
5xx 表示服务器的错误，服务器在处理请求的过程中发生了错误
"常用"
100（继续）//请求者应当继续提出请求。服务器返回此代码则意味着，服务器已收到了请求的第一部分，现正在等待接收其余部分
101（切换协议）//请求者已要求服务器切换协议，服务器已确认并准备进行切换
200（成功）//服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。
201（已创建）//请求成功且服务器已创建了新的资源。
202（已接受）//服务器已接受了请求，但尚未对其进行处理。
203（非授权信息）//服务器已成功处理了请求，但返回了可能来自另一来源的信息。
204（无内容）//服务器成功处理了请求，但未返回任何内容。
205（重置内容）//服务器成功处理了请求，但未返回任何内容。与 204 响应不同，此响应要求请求者重置文档视图（例如清除表单内容以输入新内容）。
206（部分内容）//服务器成功处理了部分 GET 请求。
300（多种选择）//服务器根据请求可执行多种操作。服务器可根据请求者来选择一项操作，或提供操作列表供请求者选择。
301（永久移动）//请求的网页已被永久移动到新位置。服务器返回此响应（作为对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码通知 Googlebot某个网页或网站已被永久移动到新位置。
302（临时移动）//服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。
303（查看其他位置）//当请求者应对不同的位置进行单独的 GET 请求以检索响应时，服务器会返回此代码。对于除 HEAD 请求之外的所有请求，服务器会自动转到其他位置。
304（未修改）//自从上次请求后，请求的网页未被修改过。服务器返回此响应时，不会返回网页内容。
305（使用代理）//请求者只能使用代理访问请求的网页。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。
307（临时重定向）//服务器目前正从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置。但由于 Googlebot 会继续抓取原有位置并将其编入索引，因此您不应使用此代码来通知 Googlebot 某个页面或网站已被移动。
400（错误请求）//服务器不理解请求的语法。
401（未授权）//请求要求进行身份验证。登录后，服务器可能会返回对页面的此响应。
403（已禁止）//服务器拒绝请求。
404（未找到）//服务器找不到请求的网页。例如，如果请求是针对服务器上不存在的网页进行的，那么，服务器通常会返回此代码。
405（方法禁用）//禁用请求中所指定的方法。
406（不接受）//无法使用请求的内容特性来响应请求的网页。
407（需要代理授权）//此状态代码与 401（未授权）类似，但却指定了请求者应当使用代理进行授权。如果服务器返回此响应，那么，服务器还会指明请求者应当使用的代理。
408（请求超时）//服务器等候请求时超时。
409（冲突）//服务器在完成请求时发生冲突。服务器必须包含有关响应中所发生的冲突的信息。服务器在响应与前一个请求相冲突的 PUT 请求时可能会返回此代码，同时会提供两个请求的差异列表。
410（已删除）//如果请求的资源已被永久删除，那么，服务器会返回此响应。该代码与 404（未找到）代码类似，但在资源以前有但现在已经不复存在的情况下，有时会替代 404 代码出现。如果资源已被永久删除，那么，您应当使用 301 代码指定该资源的新位置。
411（需要有效长度）//服务器不会接受包含无效内容长度标头字段的请求。
412（未满足前提条件）//服务器未满足请求者在请求中设置的其中一个前提条件。
413（请求实体过大）//服务器无法处理请求，因为请求实体过大，已超出服务器的处理能力。
414（请求的 URI 过长）//请求的 URI（通常为网址）过长，服务器无法进行处理。
415（不支持的媒体类型）//请求的格式不受请求页面的支持。
416（请求范围不符合要求）//如果请求是针对网页的无效范围进行的，那么，服务器会返回此状态代码。
417（未满足期望值）//服务器未满足”期望”请求标头字段的要求。 500（服务器内部错误）服务器遇到错误，无法完成请求。
501（尚未实施）//服务器不具备完成请求的功能。例如，当服务器无法识别请求方法时，服务器可能会返回此代码。
502（错误网关）//服务器作为网关或代理，从上游服务器收到了无效的响应。
503（服务不可用）//目前无法使用服务器（由于超载或进行停机维护）。通常，这只是一种暂时的状态。
504（网关超时）//服务器作为网关或代理，未及时从上游服务器接收请求。
505（HTTP 版本不受支持）//服务器不支持请求中所使用的 HTTP 协议版本。 
```
*****

## HTTP通用头:包含请求和响应消息都支持的头域
```js
信息性首部
    "Connection"        表示是否需要持久连接。（HTTP 1.1默认进行持久连接）
    "Date"              报文是什么时间创建的
    "MIME-Version"      给出发送端使用的MIME版本
    "Trailer"           指出头域在分块传输编码的尾部存在
    "Transfer-Encoding" 文件传输编码
    "Update"            给出了发送端可能想要“升级”使用的新版本或协议
    "Upgrade"           向服务器指定某种传输协议以便服务器进行转换（如果支持）
    "Via"               通知中间网关或代理服务器地址，通信协议

缓存首部
    "Pragma"            另一种随报文传送指示的方式，但并不专用于缓存
    "Cache-Control"     指定请求和响应遵循的缓存机制
    　　"Public"        响应可以被任何服务器缓存
    　　"Private"       响应可以被缓存，但只能被单个客户端访问 
    　　"no-cache"      指示请求或响应消息不能缓存  
    　　"no-store"      用于防止重要的信息被无意的发布,在请求消息中发送将使得请求和响应消息都不使用缓存
    　　"max-age"       指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。请求时缓存中的文档不能超过指定的使用期
        "s-max-age"     指定文档作为共享缓存时的最长使用时间（如果有 max-age 指令的话，以本指令为准）。私有的缓存可以忽略本指令
    　　"min-fresh"     响应必须至少在指定的这段时间之内保持新鲜
    　　"max-stale"     指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息
        "no-transform"  文档在发送之前不允许被转换,响应在提供给客户端之前不能做任何形式的修改
        "only-if-cached"只有当文档在缓存中才发送，不要联系原始服务器
        "must-revalidate"响应在提供给客户端之前必须重新向服务器验证
        "proxy-revalidate"共享的缓存在提供给客户端之前必须重新向原始服务器验证。私有的缓存可以忽略这条指令

```
## HTTP请求头
```js
请求的信息性首部
    "Client-IP"         提供了运行客户端的机器的 IP 地址
    "From"              提供了客户端用户的 E-mail 地址
    "Host"              给出了接收请求的服务器的主机名和端口号
    "Referer"           提供了包含当前请求 URI 的文档的 URL
    "UA-Color"          提供了与客户端显示器的显示颜色有关的信息
    "UA-CPU"            给出了客户端 CPU 的类型或制造商
    "UA-Disp"           提供了与客户端显示器（屏幕）能力有关的信息
    "UA-OS"             给出了运行在客户端机器上的操作系统名称及版本
    "UA-Pixels"         提供了客户端显示器的像素信息
    "User-Agent"        将发起请求的应用程序名称告知服务器
    "Keep-Alive"        显示连接的持续时间
    "Warning"           关于消息实体的警告信息 

Accept首部
    "Accept"            告诉服务器能够发送哪些媒体类型
    "Accept-Charset"    告诉服务器能够发送哪些字符集
    "Accept-Encoding"   告诉服务器能够发送哪些编码方式
    "Accept-Language"   告诉服务器能够发送哪些语言
    "Accept-Ranges"     可以请求网页实体的一个或者多个子范围字段
    "TE"                告诉服务器可以使用哪些扩展传输编码

条件请求首部
    "Expect"            允许客户端列出某请求所要求的服务器行为
    "If-Match"          只有请求内容与实体相匹配才有效
    "If-Modified-Since" 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回304代码
    "If-None-Match"     如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变
    "If-Range"          如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag
    "If-Unmodified-Since"只在实体在指定时间之后未被修改才请求成功
    "Range"             如果服务器支持范围请求，就请求资源的指定范围

安全请求首部
    "Authorization"     HTTP授权的授权证书，用户名和密码
    "cookie"            请求发送时,会把保存在该请求域名下的所有cookie值一起发送给web服务器
    "Cookie2"           用来说明请求端支持的 cookie 版本

代理请求首部
    "Max-Forwards"      限制信息通过代理和网关传送的时间
    "Proxy-Authorization"连接到代理的授权证书
    "Proxy-Connection"  与 Connection 首部相同，但这个首部是在与代理建立连接时使用的

```

## HTTP响应头
```js
信息性首部
    "Age"               从原始服务器到代理缓存形成的估算时间（以秒计，非负）
    "Public"            服务器为其资源支持的请求方法列表
    "Retry-After"       如果资源不可用的话，在此日期或时间重试
    "Server"            服务器应用程序软件的名称和版本
    "Title"             对 HTML 文档来说，就是 HTML 文档的源端给出的标题
    "Warning"           比原因短语中更详细一些的警告报文
    "refresh"           应用于重定向或一个新的资源被创造，在5秒之后重定向（由网景提出，被大部分浏览器支持）

协商首部
    "Accept-Ranges"     服务器是否支持指定范围请求及哪种类型的分段请求
    "Vary"              告诉下游代理是使用缓存响应还是从原始服务器请求 

安全响应首部
    "Proxy-Authenticate"它指出认证方案和可应用到代理的该URL上的参数
    "Server"            web服务器软件名称
    "Set-Cookie"        设置Http Cookie
    "Set-Cookie2"       与 Set-Cookie 类似，RFC 2965 Cookie 定义
    "WWW-Authenticate"  表明客户端请求实体应该使用的授权方案，要求用户登录

```

## HTTP实体头:有关实体及其内容的大量信息,告知报文的接收者它在对什么进行处理
```js
信息性头部
    "Allow"             列出了可以对此实体执行的请求方法
    "Location"          告知客户端实体实际上位于何处；用于将接收端定向到资源的（可能是新的）位置（URL）上去内容头部
    "Content-Type"      返回内容的MIME类型
    "Content-Length"    主体的长度或尺寸,这个大小是包含了所有
内容编码的，比如，对文本文件进行了 gzip 压缩的话， Content-Length 首部就是
压缩后的大小，而不是原始大小。
    "Content-Base"      解析主体中的相对 URL 时使用的基础 URL
    "Content-Encoding"  web服务器支持的返回内容压缩编码类型
    "Content-Language"  理解主体时最适宜使用的自然语言
    "Content-Location"  资源实际所处的位置
    "Content-MD5"       主体的 MD5 校验和
    "Content-Range"     如果这是部分实体，这个首部说明它是整体的哪个部分

缓存头部
    "Etag"              与此实体相关的实体标记
    "Expires"           实体数据将要失效的日期时间
    "Last-Modified"     所传输内容在服务器上创建或最后修改的日期时间

```
