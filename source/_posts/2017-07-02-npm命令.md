---
title: npm命令
date: 2017-07-02 21:04:23
categories: 构建工具
tags: npm
---
## npm作用
npm的全称是（英文：Node Package Manager），中文：包管理工具，跟NodeJS软件一起安装的包管理和分发工具，方便开发者下载、安装、上传以及管理已经安装的包。

## npm是否安装成功,注意Node.js v8.0 后npm 5.×存在问题（无法更好的升级）,切回到Node v6.x
npm -v

## 升级npm
npm i npm -g
或者npm install npm -g

## 回退npm版本
npm uni npm -g
或者npm uninstall npm -g 
如果用上述命令升级过可以使用

## 淘宝镜像命令，作用和npm一样
npm install cnpm -g

## 查看本地安装的所有模块
npm ls
或者npm list

## 查看全局安装的所有模块
npm ls -g
或者npm list -g

## 查看全局中某个模块的版本号
模块名 -v

## 安装最新的模块
npm i 模块名
或者npm install 模块名

## 安装指定版本模块
npm i 模块名@版本号
或者npm install 模块名@版本号

## 生产阶段（-S）安装包信息将加入到package.json 文件的 dependencies 字段
npm install gulp -S 或 npm install gulp --save 

## 开发阶段（-D）安装包信息将加入到package.json 文件的 devDependencies字段
 npm install gulp -D  或 npm install gulp --save-dev

## 可选阶段 （-O）安装包信息将加入到package.json 文件的 optionalDependencies字段
npm install gulp -O 或 npm install gulp --save-optional

## 精确安装指定模块版本（-ES）留意package.json 文件的 dependencies 字段，可以看出版本号中的^消失了
npm install gulp -ES 或 npm install gulp --save-exact

## 一键安装package.json里的所有模块，在package.json所在文件夹下输入命令
npm i
或者npm install

## 本地安装
npm i 模块名
或者npm install 模块名
package.json所在的文件夹

## 全局安装 （-g）
npm install 模块名 -g
安装位置在C:\Users\Administrator\AppData\Roaming\npm

## 卸载本地模块
npm uni 模块名
或者npm uninstall 模块名

## 卸载全局模块
npm uni 模块名 -g
或者npm uninstall 模块名 -g

## 初始化package.json文件
npm init (一步步填写内容)

npm init -y (快速创建package.json)
```js
{
  "name": "abc", //package.json所在文件夹名称，其他都是默认
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}

```

### name （模块名称）（必须）
```
name必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。
name不能以"_"或"."开头
不能含有大写字母
name会成为url的一部分，不能含有url非法字符
下面是官网文档的一些建议：
不要使用和node核心模块一样的名称
name中不要含有"js"和"node"。
name属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以"_"或"."开头
name属性也许会被写在require()的参数中，所以最好取个简短而语义化的值。
创建一个模块前可以先到后边的网址查查name是否已经被占用. 
```
<https://www.npmjs.com/>

### version （版本）（必须）

### scripts （脚本命令）
[原文地址](http://www.ruanyifeng.com/blog/2016/10/npm_scripts.html)
```js
{
  // ...
  "scripts": {
    "build": "node build.js"
  }
}
$ npm run build
# 等同于执行
$ node build.js
```

当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。
可以使用 Shell 通配符
*表示任意文件名，**表示任意一层子目录,防止被 Shell 转义，要将星号转义
向 npm 脚本传入参数，要使用--标明
并行执行（即同时的平行执行），可以使用&符号。
继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&&符号。
```js
"start": "node server.js"，
"install": "node-gyp rebuild"
npm run start的默认值是node server.js，
前提是项目根目录下有server.js这个脚本；
npm run install的默认值是node-gyp rebuild，
前提是项目根目录下有binding.gyp文件。
```

npm 脚本有pre和post两个钩子
```js
npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。

"prebuild": "echo I run before the build script",
"build": "cross-env NODE_ENV=production webpack",
"postbuild": "echo I run after the build script"
用户执行npm run build的时候，会自动按照下面的顺序执行。
npm run prebuild && npm run build && npm run postbuild
```

```js
npm start是npm run start
npm stop是npm run stop的简写
npm test是npm run test的简写
npm restart是npm run stop && npm run restart && npm run start的简写
具体执行顺序如下
prerestart
prestop
stop
poststop
restart
prestart
start
poststart
postrestart
```

`npm_package_前缀`
```js
npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。

{
  "name": "foo", 
  "version": "1.2.5",
  "scripts": {
    "view": "node view.js"
  }
}
那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。
```

```js
// 删除目录
"clean": "rimraf dist/*",

// 本地搭建一个 HTTP 服务
"serve": "http-server -p 9090 dist/",

// 打开浏览器
"open:dev": "opener http://localhost:9090",

// 实时刷新
 "livereload": "live-reload --port 9091 dist/",

// 构建 HTML 文件
"build:html": "jade index.jade > dist/index.html",

// 只要 CSS 文件有变动，就重新执行构建
"watch:css": "watch 'npm run build:css' assets/styles/",

// 只要 HTML 文件有变动，就重新执行构建
"watch:html": "watch 'npm run build:html' assets/html",

// 部署到 Amazon S3
"deploy:prod": "s3-cli sync ./dist/ s3://example-com/prod-site/",

// 构建 favicon
"build:favicon": "node scripts/favicon.js",
```

### description （描述）
方便别人了解你的模块作用，方便在npm search中搜索

### keywords （关键字）
一个字符串数组，方便在npm search中搜索

### homepage （项目主页URL）
注意: 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。

### bugs （bug提交地址url）

### license （许可证）
为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。
你可以在<https://spdx.org/licenses/>这个地址查阅协议列表 。

### author （作者）

### contributors （贡献者数组）

### maintaiers （维护者）

### repository （代码仓库）
指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。
```
{ "name" : "foo"
, "config" : { "port" : "8080" } }
```

### config （配置）
用来设置一些项目不怎么变化的项目配置，例如port等。


### dependencies （生成环境）
```
version 精确匹配版本
>version 必须大于某个版本
>=version 大于等于
<version 小于
<=versionversion 小于
~version "约等于"，具体规则详见semver文档
^version "兼容版本"具体规则详见semver文档
1.2.x 仅一点二点几的版本
http://... 见下面url作为denpendencies的说明
任何版本
"" 空字符，和*相同
version1 - version2 相当于 >=version1 <=version2.
range1 || range2 范围1和范围2满足任意一个都行
git... 见下面git url作为denpendencies的说明
user/repo See 见下面GitHub仓库的说明
tag 发布的一个特殊的标签，见npm-tag的文档 https://docs.npmjs.com/getting-started/using-tags
path/path/path 见下面本地模块的说明
下面的写法都是可以的:
{ "dependencies" :
  { "foo" : "1.0.0 - 2.9999.9999"
  , "bar" : ">=1.0.2 <2.1.2"
  , "baz" : ">1.0.2 <=2.3.4"
  , "boo" : "2.0.1"
  , "qux" : "<1.0.0 || >=2.3.1 <2.4.5 || >=2.5.2 <3.0.0"
  , "asd" : "http://asdf.com/asdf.tar.gz"
  , "til" : "~1.2"
  , "elf" : "~1.2.3"
  , "two" : "2.x"
  , "thr" : "3.3.x"
  , "lat" : "latest"
  , "dyl" : "file:../dyl"
  }
}
```

### devDependencies (开发环境)
```
如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。
在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。
这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。
对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。
例如:

{ "name": "ethopia-waza",
  "description": "a delightfully fruity coffee varietal",
  "version": "1.2.3",
  "devDependencies": {
    "coffee-script": "~1.6.3"
  },
  "scripts": {
    "prepublish": "coffee -o lib/ -c src/waza.coffee"
  },
  "main": "lib/waza.js"
}
prepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试
```

### peerDependencies (对等的依赖)
```
有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require("grunt")这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies：

{
  "name": "tea-latte",
  "version": "1.3.5",
  "peerDependencies": {
    "tea": "2.x"
  }
}
上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的：
├── tea-latte@1.3.5
└── tea@2.2.0
这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。
```

### BundledDependencies (捆绑的依赖)
指定发布的时候会被一起打包的模块。

### files (文件名或文件夹名)
如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了如npmignore）

### main （程序的主入口文件）
如果你的模块被命名为foo，用户安装了这个模块并通过require("foo")来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。
它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。

### bin
很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）
如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：
`{ "bin" : { "myapp" : "./cli.js" } }`

模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\Users\username\AppData\Roaming\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。
因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。
如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：

```
{ "name": "my-program"
, "version": "1.2.5"
, "bin": "./path/to/program" }
```

作用和如下写法相同:
```
{ "name": "my-program"
, "version": "1.2.5"
, "bin" : { "my-program" : "./path/to/program" } }
```

### man
制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。
如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:
```
{ "name" : "foo"
, "version" : "1.2.3"
, "description" : "A packaged foo fooer for fooing foos"
, "main" : "foo.js"
, "man" : "./man/doc.1"
}
```
通过man foo命令会得到 ./man/doc.1 文件的内容。
如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：
```
{ "name" : "foo"
, "version" : "1.2.3"
, "description" : "A packaged foo fooer for fooing foos"
, "main" : "foo.js"
, "man" : [ "./man/foo.1", "./man/bar.1" ]
}
```
会创建一些文件来作为man foo和man foo-bar命令的结果。
man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。
```
{ "name" : "foo"
, "version" : "1.2.3"
, "description" : "A packaged foo fooer for fooing foos"
, "main" : "foo.js"
, "man" : [ "./man/foo.1", "./man/foo.2" ]
}
```
会创建 man foo 和 man 2 foo 两条命令。

### os （指定模块运行的系统）
可以指定你的模块只能在哪个操作系统上跑：
"os" : [ "darwin", "linux" ]
也可以指定黑名单而不是白名单：
"os" : [ "!win32" ]
服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...

### cpu （指定cup架构）
限制模块只能在某某cpu架构下运行
"cpu" : [ "x64", "ia32" ]
同样可以设置黑名单:
"cpu" : [ "!arm", "!mips" ]
cpu架构通过 process.arch 判断

### preferGlobal
如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。

### private
如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。

### publishConfig
这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。

## .npmignore （文件或者文件夹排除，类似.gitignore）

